{
  "hash": "f712bb7c6632aa7760f9d771fec14ecb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Matrices and Dataframes\"\nsubtitle: \"StartR Workshop\"\ndescription: \"Matrices | Dataframes | Indexing | Factors\"\nauthor: \"Maik Bieleke, PhD\"\ninstitute: \"University of Konstanz\"\ndate: 11/23/2024\ndate-format: long\nformat: \n  revealjs:\n    fontsize: 24pt\n    chalkboard: false\n    embed-resources: true\n    slide-number: true\n    theme: [simple, _styles/unikn.scss]\n    logo: _styles/icon.png\n    footer: \"[www.maikbieleke.com](https://www.maikbieleke.com)\"\n    margin: 0.2\n    incremental: false \n    slide-level: 2\n    highlight-style: a11y\n    preview-links: true\nfrom: markdown+emoji\nrevealjs-plugins:\n  - attribution\n---\n\n\n# Matrices {background-color=\"white\" background-image=\"figures/matrix.jpg\" background-opacity=\"0.4\"}\n\n::: footer\nPhoto courtesy of [@markusspiske](https://unsplash.com/de/@markusspiske)\n:::\n\n## What are matrices?\n\nMatrices are combinations of vectors. Like vectors, they can only contain values of the same type (e.g., numeric or character). If you combine vectors of different types, they will be coerced into the same type.\n\nThere are two main ways to create matrices in R:\n\n-   from existing vectors with `cbind()` and `rbind()`\n-   from scratch with `matrix()`\n\n## Matrices from existing vectors: cbind()\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Create vectors\nx <- c(10, 11, 12, 13, 14, 15)\ny <- c(20, 21, 22, 23, 24, 25)\nz <- c(30, 31, 32, 33, 34, 35)\n```\n:::\n\n\nThe `cbind()` function combines vectors into a matrix by binding them together by column.\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\ncbind(x, y, z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      x  y  z\n[1,] 10 20 30\n[2,] 11 21 31\n[3,] 12 22 32\n[4,] 13 23 33\n[5,] 14 24 34\n[6,] 15 25 35\n```\n\n\n:::\n:::\n\n\nNote that the vector names are used as column names.\n:::\n\n::: {.column width=\"50%\"}\n![](figures/cbind.png)\n:::\n:::\n\n## Matrices from existing vectors: rbind()\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Create vectors\nx <- c(10, 11, 12, 13, 14, 15)\ny <- c(20, 21, 22, 23, 24, 25)\nz <- c(30, 31, 32, 33, 34, 35)\n```\n:::\n\n\nThe `rbind()` function combines vectors into a matrix by binding them together by row\n\n::: columns\n::: {.column width=\"50%\"}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nrbind(x, y, z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [,1] [,2] [,3] [,4] [,5] [,6]\nx   10   11   12   13   14   15\ny   20   21   22   23   24   25\nz   30   31   32   33   34   35\n```\n\n\n:::\n:::\n\n\nNote that the vector names are used as row names.\n:::\n\n::: {.column width=\"50%\"}\n![](figures/rbind.png)\n:::\n:::\n\n## Matrices from scratch: matrix()\n\nThe `matrix()` function is an explicit way to create matrices from scratch. It takes the following arguments:\n\n-   `data`: a vector containing the data\n-   `nrow`: the number of rows\n-   `ncol`: the number of columns\n-   `byrow`: logical value indicating whether the matrix should be filled by row (`FALSE`, default) or by column (`TRUE`)\n\n## Examples\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Create a vector with data\ndata <- 1:10\n```\n:::\n\n\nThe matrix function can transforms the data into a variety of matrices.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Create a matrix with 2 rows and 5 columns\nmatrix(data, nrow = 2, ncol = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Now fill by row instead of by column\nmatrix(data, nrow = 2, ncol = 5, byrow = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Create a matrix with 5 rows and 2 columns\nmatrix(data, nrow = 5, ncol = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]    1    6\n[2,]    2    7\n[3,]    3    8\n[4,]    4    9\n[5,]    5   10\n```\n\n\n:::\n:::\n\n\n## Indexing with matrices\n\n-   Remember that vectors are indexed like this: `x[i]`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Create a vector with values\n    vec <- 12:1\n    vec\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n     [1] 12 11 10  9  8  7  6  5  4  3  2  1\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    vec[3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 10\n    ```\n    \n    \n    :::\n    :::\n\n\n-   Matrices are indexed like this: `x[i, j]`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Create a matrix\n    mat <- matrix(vec, nrow = 4, ncol = 3)\n    mat\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n         [,1] [,2] [,3]\n    [1,]   12    8    4\n    [2,]   11    7    3\n    [3,]   10    6    2\n    [4,]    9    5    1\n    ```\n    \n    \n    :::\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Get the value in the 2nd row and 3rd column\n    mat[2, 3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 3\n    ```\n    \n    \n    :::\n    :::\n\n\n## Examples\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]   12    8    4\n[2,]   11    7    3\n[3,]   10    6    2\n[4,]    9    5    1\n```\n\n\n:::\n:::\n\n\n::: columns\n::: {.column width=\"50%\"}\nUse vectors to index multiple rows and/or columns.\n\n-   Getting multiple row values\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # 2nd and 4th value in 1st column\n    mat[c(2, 4), 1]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 11  9\n    ```\n    \n    \n    :::\n    :::\n\n\n-   Getting multiple column values\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # 2nd to 3rd value in 4th row\n    mat[4, 2:3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 5 1\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\"}\nLeave rows and/or column index empty to get all values.\n\n-   Getting all rows values\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # all row values in 1st column\n    mat[, 1]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 12 11 10  9\n    ```\n    \n    \n    :::\n    :::\n\n\n-   Getting all column values\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # ll column values in 4th row\n    mat[4, ]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 9 5 1\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n## Exercise :pencil2: {auto-animate=\"true\" background-color=\"white\" background-image=\"figures/tiles.jpg\" background-opacity=\"0.2\"}\n\n::: attribution\nPhoto courtesy of [\\@kolbymilton](https://unsplash.com/@kolbymilton)\n:::\n\n1.  Recall that `letters` is a vector of the alphabet. Create a matrix `m1` with 3 rows and 5 columns using the first 15 letters of the alphabet.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    m1 <- matrix(letters[1:15], nrow = 3, ncol = 5)\n    ```\n    :::\n\n\n2.  Use `cbind()` to attach a sixth column with the letters `p`, `q`, and `r`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    m1 <- cbind(m1, c(\"p\", \"q\", \"r\"))\n    ```\n    :::\n\n\n3.  Extract the 2nd to 4th column assign them to a new matrix `m2`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    m2 <- m1[, 2:4]\n    ```\n    :::\n\n\n4.  Create a new matrix `m3` by removing the 3rd row of `m2`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    m3 <- m2[-3, ]\n    ```\n    :::\n\n\n\n\n\n\n\n\n\n\n\n# Dataframes {background-color=\"wite\" background-image=\"figures/dataframe.png\" background-opacity=\"0.2\"}\n\n## What are dataframes?\n\nDataframes are similar to matrices, but they can contain different types of data (e.g., numeric and character). Because of this flexibility, they are commonly used to store data in R.\n\nDataframes are often imported from external sources (e.g., Excel, SPSS, or CSV files). However, we can also create dataframes from scratch with the `data.frame()`function.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\ndata <- data.frame(\"id\" = c(1, 2, 3, 4, 5),\n                   \"sex\" = c(\"m\", \"m\", \"m\", \"f\", \"f\"),\n                   \"age\" = c(99, 46, 23, 54, 23))\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id sex age\n1  1   m  99\n2  2   m  46\n3  3   m  23\n4  4   f  54\n5  5   f  23\n```\n\n\n:::\n:::\n\n\n## Selecting rows\n\n::: columns\n::: {.column width=\"50%\"}\nWe can select rows based on their numerical index (slicing).\n\n-   Numeric indexing (slicing)\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Get the 2nd and 3rd row\n    data[2:3, ]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n      id sex age\n    2  2   m  46\n    3  3   m  23\n    ```\n    \n    \n    :::\n    :::\n\n\n-   Using `dplyr::slice()`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Get the 2nd and 3rd row\n    dplyr::slice(data, 2:3)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n      id sex age\n    1  2   m  46\n    2  3   m  23\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\"}\nWe can select rows based on a logical condition (filtering).\n\n-   Logical indexing\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Get rows for females\n    data[data$sex == \"f\", ]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n      id sex age\n    4  4   f  54\n    5  5   f  23\n    ```\n    \n    \n    :::\n    :::\n\n\n-   Using `dplyr::filter()`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Get rows for females\n    dplyr::filter(data, sex == \"f\")\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n      id sex age\n    1  4   f  54\n    2  5   f  23\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n## Selecting columns\n\n::: columns\n::: {.column width=\"50%\"}\n-   Numeric indexing\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Get the 2nd and 3rd column\n    data[, 2:3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n      sex age\n    1   m  99\n    2   m  46\n    3   m  23\n    4   f  54\n    5   f  23\n    ```\n    \n    \n    :::\n    :::\n\n\n-   Using `dplyr::select()`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Get the 2nd and 3rd column\n    dplyr::select(data, 2:3)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n      sex age\n    1   m  99\n    2   m  46\n    3   m  23\n    4   f  54\n    5   f  23\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\"}\n-   Indexing by name\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Get the \"sex2 and \"age\" columns\n    data[, c(\"sex\", \"age\")]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n      sex age\n    1   m  99\n    2   m  46\n    3   m  23\n    4   f  54\n    5   f  23\n    ```\n    \n    \n    :::\n    :::\n\n\n-   Using `dplyr::select()`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Get the \"sex2 and \"age\" columns\n    dplyr::select(data, sex, age)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n      sex age\n    1   m  99\n    2   m  46\n    3   m  23\n    4   f  54\n    5   f  23\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n## The `$` operator\n\n::: columns\n::: {.column width=\"80%\"}\nRetrieving a single column of a dataframe is so common that R provides an own shortcut for this task: **the `$` operator**.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id sex age\n1  1   m  99\n2  2   m  46\n3  3   m  23\n4  4   f  54\n5  5   f  23\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Get the \"age\" column\ndata$age\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 99 46 23 54 23\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Get the \"sex\" column\ndata$sex\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"m\" \"m\" \"m\" \"f\" \"f\"\n```\n\n\n:::\n:::\n\n\nNote that the `$` operator returns the variable as a vector.\n:::\n\n::: {.column width=\"20%\"}\n![](figures/dollar.png)\n:::\n:::\n\n\n\n## Adding columns\n\nThe `$` operator is a simple way to add new columns to a dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Adding a new character and a new numeric column\ndata$condition <- c(\"con\", \"con\", \"exp\", \"con\", \"exp\")\ndata$score <- c(5.5, 2.3, 4.7, 6.7, 3.0)\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id sex age condition score\n1  1   m  99       con   5.5\n2  2   m  46       con   2.3\n3  3   m  23       exp   4.7\n4  4   f  54       con   6.7\n5  5   f  23       exp   3.0\n```\n\n\n:::\n:::\n\n\nAn alternative is the `dplyr::mutate()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Adding a new character column\ndata <- dplyr::mutate(data, \n                      time = c(\"t1\", \"t2\", \"t1\", \"t2\", \"t2\"),\n                      weight = c(70, 80, 65, 60, 75))\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id sex age condition score time weight\n1  1   m  99       con   5.5   t1     70\n2  2   m  46       con   2.3   t2     80\n3  3   m  23       exp   4.7   t1     65\n4  4   f  54       con   6.7   t2     60\n5  5   f  23       exp   3.0   t2     75\n```\n\n\n:::\n:::\n\n\n\n\n## Renaming columns\n\nWe have already used the names of colums to select them. To see all names of a dataframe, use the `names()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Get the names of the dataframe\nnames(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"id\"        \"sex\"       \"age\"       \"condition\" \"score\"     \"time\"     \n[7] \"weight\"   \n```\n\n\n:::\n:::\n\n\nThe names can be changed by assigning new values.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Adding a new character column\nnames(data)[4] <- \"group\"\nnames(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"id\"     \"sex\"    \"age\"    \"group\"  \"score\"  \"time\"   \"weight\"\n```\n\n\n:::\n:::\n\n\nAn alternative is the `dplyr::rename()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Adding a new character column\ndata <- dplyr::rename(data, gender = sex)\nnames(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"id\"     \"gender\" \"age\"    \"group\"  \"score\"  \"time\"   \"weight\"\n```\n\n\n:::\n:::\n\n\n\n\n## Exercise :pencil2: {auto-animate=\"true\" background-color=\"white\" background-image=\"figures/height.jpg\" background-opacity=\"0.2\"}\n\n::: attribution\nPhoto courtesy of [@siora18](https://unsplash.com/@siora18)\n:::\n\n::: columns\n::: {.column width=\"80%\"}\n1.  Create a dataframe `demo` based on the table on the right.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    demo <- data.frame(\n      name = c(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eva\"),\n      weight = c(165, 175, 180, NA, 160))\n    ```\n    :::\n\n\n3.  Correct the name of the second column to `height`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    names(demo)[2] <- \"height\" \n    # alternative: demo <- dplyr::rename(demo, height = weight)\n    ```\n    :::\n\n\n2.  Using the `$` operator, convert height from cm to m.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    demo$height <- demo$height / 100\n    # alternative: demo <- dplyr::mutate(demo, height = height / 100)\n    ```\n    :::\n\n\n4.  Compute the average height.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    height_mean <- mean(demo$height, na.rm = TRUE)\n    ```\n    :::\n\n    \n5.  Select rows with above-average height.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    demo[demo$height > height_mean, ]\n    ```\n    :::\n\n:::\n::: {.column width=\"20%\"}\n| name    | weight    |\n|---------|-----------|\n| Alice   | 165       |\n| Bob     | 175       |\n| Charlie | 180       |\n| David   |           |\n| Eva     | 160       |\n:::\n:::\n\n# Factors {background-color=\"wite\" background-image=\"figures/garbage.jpg\" background-opacity=\"0.2\"}\n\n::: footer\nPhoto courtesy of [@pawel_czerwinski](https://unsplash.com/de/@pawel_czerwinski)\n:::\n\n\n\n## What are factors?\n\nDataframes often contain factors that are used to represent categorical variables (e.g., sex, education level, blood type).\n\n::: {.callout-important icon=\"false\"}\n## A factor can contain only predefined values (called levels) with unique labels. Factors are created using the `factor()` function.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Creating a character vector\nsex = c(\"m\", \"m\", \"m\", \"f\", \"f\")\nsex\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"m\" \"m\" \"m\" \"f\" \"f\"\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Converting to factor with two levels labelled \"f\" and \"m\"\nfactor(sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] m m m f f\nLevels: f m\n```\n\n\n:::\n:::\n\n\nFactors are very similar to character vectors, but they are treated differently in many statistical analyses and data visualizations.\n\n## Change level order\n\nWe can change the order of the levels by explicitly specifying them in the `factor()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Create a character vector\nsex = c(\"m\", \"m\", \"m\", \"f\", \"f\")\n\n# Order: \"f\", \"m\"\nfactor(sex, levels = c(\"f\", \"m\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] m m m f f\nLevels: f m\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Order: \"m\", \"f\"\nfactor(sex, levels = c(\"m\", \"f\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] m m m f f\nLevels: m f\n```\n\n\n:::\n:::\n\n\nThis can be useful for reordering the levels in an analysis or plot (e.g., to change the order of the bars for males and females in a barplot).\n\n## Renaming factor levels\n\nWe can also rename the levels of a factor by specifying the new names in the `levels` argument of the `factor()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Create a character vector\nsex = c(\"m\", \"m\", \"m\", \"f\", \"f\")\n\n# Ordinary factor\nfactor(sex, levels = c(\"f\", \"m\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] m m m f f\nLevels: f m\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Renamed factor\nfactor(sex, levels = c(\"m\", \"f\"), labels = c(\"male\", \"female\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] male   male   male   female female\nLevels: male female\n```\n\n\n:::\n:::\n\n\nThis can be useful for relabelling the levels in an analysis or plot.\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}