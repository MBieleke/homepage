{
  "hash": "02dc8b955430073fe1f26c7feb046e2f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Scalars and Vectors\"\nsubtitle: \"StartR Workshop\"\ndescription: \"Scalars | Vectors | Indexing | Assignments | Operations | Missings\"\nauthor: \"Maik Bieleke, PhD\"\ninstitute: \"University of Konstanz\"\ndate: 11/23/2024\ndate-format: long\nformat: \n  revealjs:\n    fontsize: 24pt\n    chalkboard: false\n    embed-resources: true\n    slide-number: true\n    theme: [simple, _styles/unikn.scss]\n    logo: _styles/icon.png\n    footer: \"[www.maikbieleke.com](https://www.maikbieleke.com)\"\n    margin: 0.2\n    incremental: false \n    slide-level: 3\n    highlight-style: a11y\n    preview-links: true\nfrom: markdown+emoji\nrevealjs-plugins:\n  - attribution\n---\n\n\n\n\n# Scalars {background-color=\"white\" background-image=\"figures/scalars.png\" background-opacity=\"0.5\"}\n\n\n\n```{=html}\n<style> td,th {font-size: 20px} </style>\n```\n\n\n\n### What are scalars?\n\nScalars are the simplest object in R. They are single values that can be assigned to a variable.\n\n::: callout-important\n## The assignment operator `<-` is used for creating objects like scalars.\n\n`scalar <- ...`\n:::\n\nThe most common types of scalars are **numerical** and **character**.\n\n::: columns\n::: {.column width=\"50%\"}\n-   numerical scalars\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    x <- 10\n    x\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 10\n    ```\n    \n    \n    :::\n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    y <- 3 / 100\n    y\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 0.03\n    ```\n    \n    \n    :::\n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    z <- (x + y) / y\n    z\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 334.3333\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n\n::: {.column width=\"50%\"}\n-   character scalars\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- \"Hello\"\n    a\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"Hello\"\n    ```\n    \n    \n    :::\n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    b <- \"12345\"\n    b\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"12345\"\n    ```\n    \n    \n    :::\n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    c <- \"Hello World!\"\n    c\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"Hello World!\"\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n:::\n\n### Types of Scalars\n\nR treats different types of scalars differently. For example, you can add two numerical values, but you cannot add two character values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Adding two numerical values: works fine\na <- 1\nb <- 2\na + b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Adding two character values: gives an error\na <- \"1\"\nb <- \"2\"\na + b\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in a + b: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\n\n### Mathematical functions\n\nR has many built-in mathematical functions that can be applied to scalars.\n\n| Function                 | Description                                       | Example                  |\n|-------------------|-----------------------------------|-------------------|\n| `abs(x)`                 | absolute value of x                               | `abs(-4) = 4`            |\n| `sqrt(x)`                | square root of x                                  | `sqrt(25) = 5`           |\n| `ceiling(x), floor(x)`   | smallest integer not less (greater) than x        | `ceiling(3.475) = 4`     |\n| `trunc(x)`               | integer formed by truncating values in x toward 0 | `trunc(5.99) = 5`        |\n| `round(x, n)`            | round x to n decimal places                       | `round(3.475, 2) = 3.48` |\n| `signif(x, n)`           | round x to n significant digits                   | `signif(3.475, 2) = 3.5` |\n| `cos(x), sin(x), tan(x)` | trigonometric functions                           | `cos(2) = -0.416`        |\n| `log(x, n)`              | Logarithm of x to the base n                      | `log(5, 2) = 2.32`       |\n| `log(x), log10(x)`       | natural and common logarithm                      | `log(10) = 2.3026`       |\n| `exp(x)`                 | exponential function                              | `exp(2.3026) = 10`       |\n| `x %% y`                 | x modulo y (remainder of x divided by y)          | `7 %% 3 = 1`             |\n\nNote that these functions can also be applied to vectors, in which case they will be applied elementwise.\n\n\n\n\n\n\n\n\n\n\n# Vectors {background-color=\"white\" background-image=\"figures/vectors.png\" background-opacity=\"0.5\"}\n\n## Basics\n\n### What are vectors?\n\nVectors can be thought of as a collection of scalars. They are the most common data type in R.\n\n::: callout-important\n## The `c()` function is used for creating vectors.\n\n`vector <- c(...)`\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n-   Vectors from scalars\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Combining scalars\n    a <- c(1, 3, 5)\n    a\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 3 5\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n\n::: {.column width=\"50%\"}\n-   Vectors from vectors\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Combining vectors\n    a <- c(\"a\", \"b\", \"c\")\n    b <- c(\"d\", \"e\")\n    c <- c(a, b)\n    c\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"a\" \"b\" \"c\" \"d\" \"e\"\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n:::\n\n### Types of vectors\n\n::: columns\n::: {.column width=\"60%\"}\nAnalogous to scalars, vectors can only contain values of the same type. Different types will be coerced into the same type.\n\nFor numerical and character values, coercion will always result in character values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\na <- c(1, 2, 3, \"a\", \"b\", \"c\")\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\" \"2\" \"3\" \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"40%\"}\n![](figures/coercion.jpg)\n:::\n:::\n\n### Length of vectors\n\nThe length of a vector is the number of elements it contains.\n\n::: callout-important\n## The `length()` function returns the number of elements in a vector.\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n-   Numerical scalar\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- 1\n    length(a)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1\n    ```\n    \n    \n    :::\n    :::\n\n\n    \n-   Character scalar\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- \"This is a sentence.\"\n    length(a)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n\n::: {.column width=\"50%\"}\n-   Numerical vector\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(11, 2, 333, 4, 5555)\n    length(a)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 5\n    ```\n    \n    \n    :::\n    :::\n\n\n    \n-   Character vector\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(\"abc\", \"def\", \"geh\")\n    length(a)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 3\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n:::\n\n\n\n## Regular vectors\n\n### Colon operator (`:`)\n\nR has built-in operators and functions for creating regular sequences as vectors.\n\n::: callout-important\n## The colon operator (a`:`b) creates a numeric vector from a to b in steps of 1.\n\n`a:b`\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n-   Counting up\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    1:5\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2 3 4 5\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   Counting down\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    5:1\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 5 4 3 2 1\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n\n::: {.column width=\"50%\"}\n-   Decimal values\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    5.5:10.5\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]  5.5  6.5  7.5  8.5  9.5 10.5\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   Excluding boundaries\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    5.5:10\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 5.5 6.5 7.5 8.5 9.5\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n:::\n\n### Sequence function: `seq()`\n\nSometimes more flexibility is needed when creating a sequence of numbers than the colon operator can provide.\n\n::: callout-important\n## The `seq()` function creates a numeric vector from a to b with a desired number of steps or a desired length.\n\n`seq(from = a, to = b, by = step, length.out = length)`\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n-   Steps\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    seq(from = 1, to = 3, \n        by = 0.5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1.0 1.5 2.0 2.5 3.0\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n\n::: {.column width=\"50%\"}\n-   Length\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    seq(from = 1, to = 10, \n        length.out = 4)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]  1  4  7 10\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n:::\n\n### Repetition function: `rep()`\n\nWe can also create vectors in which certain values are repeated.\n\n::: callout-important\n## The `rep()` function creates a numeric or characzter vector in which a scalar or vector is repeated a desired number of times or to a desired length.\n\n`rep(x, times = n, length.out = n, each = n)`\n:::\n\n::: columns\n::: {.column width=\"25%\"}\n-   Repeat x\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    rep(x = 3, \n        times = 5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 3 3 3 3 3\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n\n::: {.column width=\"37%\"}\n-   Repeat values of x\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    rep(x = c(1, 2), \n        each = 2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 1 2 2\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n\n::: {.column width=\"37%\"}\n-   Desired length\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    rep(x = c(\"a\", \"b\"), \n        length.out = 5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"a\" \"b\" \"a\" \"b\" \"a\"\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n:::\n\n\n\n## Exercise :pencil2: {auto-animate=\"true\" background-color=\"white\" background-image=\"figures/sequence.jpg\" background-opacity=\"0.2\"}\n\n::: {.attribution}\nPhoto courtesy of [@polarmermaid](https://unsplash.com/@polarmermaid)\n:::\n\n1.  Create the scalar object `x` with the value `10`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    x <- 10\n    ```\n    :::\n\n\n\n2.  What is the length of vector `y` defined as `y <- 1:x`?\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    y <- 1:x\n    length(y)\n    ```\n    :::\n\n\n    \n3.  Create a vector `z` from 11 to 100 in steps of 2.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    z <- seq(1, 100, by = 2)\n    ```\n    :::\n\n\n\n4.  Create a vector `yz` with all elements of `y` and `z` combined.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    yz <- c(y, z)\n    ```\n    :::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Indexing Vectors {background-color=\"white\" background-image=\"figures/select-vector.jpg\" background-opacity=\"0.2\"}\n\n::: footer\nPhoto courtesy of Pixabay\n:::\n\n## Numerical indexing\n\n### Indexing with positive integers\n\nSpecify a scalar or a vector of positive integers corresponding to the values you want to extract.\n\n::: callout-important\n## The `[]`operator is used for indexing vectors.\n:::\n\n::: columns\n::: {.column width=\"50%\"}\n-   Extract a single value\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Extract the 3rd value\n    x <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\n    x[3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"c\"\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n\n::: {.column width=\"50%\"}\n-   Extract several values\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Extract the first three values\n    x <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\n    x[1:3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"a\" \"b\" \"c\"\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n:::\n\n### Indexing with negative integers\n\nSpecify a scalar or a vector of negative integers corresponding to the values you want to exclude.\n\n::: columns\n::: {.column width=\"50%\"}\n-   Exclude a single value\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Exclude the 5th value\n    x <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\n    x[-5]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"a\" \"b\" \"c\" \"d\"\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n\n::: {.column width=\"50%\"}\n-   Exclude several values\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Exclude every second value\n    x <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\n    x[-seq(from = 1, to = 5, by = 2)]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"b\" \"d\"\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n:::\n\n## Logical indexing\n\n### Logical vectors\n\nWe already know numerical and character vectors. Logical vectors are the third type of vectors in R. They can only have the values `TRUE` and `FALSE` (or `T` and `F` also works).\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Create a logical vector manually\nx <- c(TRUE, FALSE, TRUE, FALSE, TRUE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\nLogical vectors are commonly created by applying logical operators to numerical or character vectors. One example is the equality operator `==` which returns `TRUE` if two values are equal and `FALSE` otherwise.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nx <- 5 # set the value of x to 5\nx == 5 # check whether x has the value 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n### Logical operators\n\nAn overview of the most common logical operators:\n\n|        |           |        |              |          |                       |\n|--------|-----------|--------|--------------|----------|-----------------------|\n| `a==b` | equal     | `a>b`  | greater than | `a>=b`   | greater than or equal |\n| `a!=b` | not equal | `a<b`  | less than    | `a<=b`   | smaller than or equal |\n| `a|b`  | or        | `!a`   | not          | `any(a)` | at least one          |\n| `a&b`  | and       | `%in%` | in set       | `all(a)` | everything            |\n\n### Examples\n\n::: {.fragment .fade-in-then-semi-out}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n3 < 5 # is 3 smaller than 5?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n5 <= 2 # is 5 smaller than or equal to 2?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n!(3 == 5) # is 3 not equal to 5?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nc(4, 5) %in% c(1, 2, 3, 4) # are 4 and 5 in the vector ?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nc(\"a\", \"b\", \"c\", \"d\") == \"c\" # are the values of the vector equal to \"c\"?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nany(c(\"a\", \"b\", \"c\", \"d\") == \"c\" ) # is at least one value equal to \"c\"?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n(3 > 7) | (5 < 10) # is 3 greater than 7 OR 5 smaller than 10?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n(3 > 7) & (5 < 10) # is 3 greater than 7 AND 5 smaller than 10?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n:::\n\n\n### Indexing with logical vectors\n\n![](figures/logical-indexing.png)\n\n### Examples\n\n::: columns\n::: {.column width=\"50%\"}\n-   equality operator\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    x <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\n    x[x == \"c\"]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"c\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   inequality operator\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- 1:5\n    a[a < 3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   negation operator\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- 1:5\n    b <- 3\n    a[!a == b]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2 4 5\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n\n::: {.column width=\"50%\"}\n-   and-operator\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- 1:10\n    a[a < 4 & a > 6]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    integer(0)\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   or-operator\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- 1:10\n    a[a < 3 | a > 7]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]  1  2  8  9 10\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   set-operator\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    x <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\n    y <- c(\"b\", \"g\")\n    y[y %in% x]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"b\"\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n:::\n\n## Value assignment\n\n### Changing vector values\n\nCombine indexing and assignment to change values.\n\n::: columns\n::: {.column width=\"50%\"}\n-   Change a single value\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Define a new vector\n    x <- c(1, 2, 3, 4, 5)\n    \n    # Change the 3rd value to 8\n    x[3] <- 8\n    x\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2 8 4 5\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n\n::: {.column width=\"50%\"}\n-   Change several values\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Define a new vector\n    x <- c(1, 2, 3, 4, 5)\n    \n    # Change the last two values to 7 and 9\n    x[c(4, 5)] <- c(7, 9)\n    x\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2 3 7 9\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n:::\n\nAs always, we can also use logical indexing to change values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nx <- c(\"a\", \"b\", \"b\", \"c\", \"d\", \"b\", \"e\", \"f\", \"b\", \"b\")\n\n# Change all instances of letter \"b\" to letter \"z\"\nx[x == \"b\"] <- \"z\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"a\" \"z\" \"z\" \"c\" \"d\" \"z\" \"e\" \"f\" \"z\" \"z\"\n```\n\n\n:::\n:::\n\n\n\n## Operations on vectors\n\n### Elementwise operations\n\nOperations on vectors are performed elementwise.\n\n::: columns\n::: {.column width=\"50%\"}\n-   Adding a single value\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(1, 2, 3, 4, 5)\n    a + 1\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 2 3 4 5 6\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   Adding two vectors\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(1, 2, 3, 4, 5)\n    b <- c(10, 20, 30, 40, 50)\n    a + b\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 11 22 33 44 55\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   Computing the square root\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    b <- c(4, 9, 16)\n    sqrt(b)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 2 3 4\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n\n::: {.column width=\"50%\"}\n-   Dividing by a single value\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    d <- c(10, 100, 1000)\n    d / 10\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]   1  10 100\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   Product of two vectors\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(10, 100, 1000)\n    b <- c(2, 3, 4)\n    a * b\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]   20  300 4000\n    ```\n    \n    \n    :::\n    :::\n\n\n\n-   Exponentiation of vectors\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(2, 3, 4)\n    b <- c(2, 3, 4)\n    a^b\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]   4  27 256\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n:::\n\n### Reycling principle\n\n::: columns\n::: {.column width=\"70%\"}\nAn operation on two vectors of different lengths will recycle the shorter vector to match the length of the longer vector - without warning.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\na <- c(1, 2, 3, 4, 5)\nb <- c(0.5, 1.0)\na + b\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in a + b: longer object length is not a multiple of shorter object\nlength\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.5 3.0 3.5 5.0 5.5\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column width=\"30%\"}\n![](figures/recycling.png)\n:::\n:::\n\nThis is also why operations with scalars work on vectors. They are recycled to the length of the vector.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\na <- c(2, 3, 4)\na^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  9 16\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nb <- c(2, 2, 2)\na^b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  9 16\n```\n\n\n:::\n:::\n\n\n\n### Statistical functions\n\nR has many built-in statistical functions that can be applied to vectors.\n\n| Function    | Description             | Example for `x <- c(1, 2, 2, 5)` |\n|-------------|-------------------------|----------------------------------|\n| `mean(x)`   | mean                    | `mean(x) = 2.5`                  |\n| `sum(x)`    | sum                     | `sum(x) = 10`                    |\n| `median(x)` | median                  | `median(x) = 2`                  |\n| `sd(x)`     | standard deviation      | `sd(x) = 1.732051`               |\n| `var(x)`    | variance                | `var(x) = 3`                     |\n| `range(x)`  | range                   | `range(x) = 1 5`                 |\n| `min(x)`    | minimum                 | `min(x) = 1`                     |\n| `max(x)`    | maximum                 | `max(x) = 5`                     |\n\n\n\n### Other functions\n\nSome other, non-statisitcal functions for vectors are:\n\n| Function    | Description                | Example for `x <- c(3, 8, 8, 5)` |\n|-------------|----------------------------|----------------------------------|\n| `sort(x)`   | sorts the elements         | `sort(x) = 3 5 8 8`              |\n| `rev(x)`    | reversed order of elements | `rev(x) = 5 8 8 3`               |\n| `length(x)` | number of elements         | `length(x) = 4`                  |\n| `unique(x)` | unique elements            | `unique(x) = 3 8 5`              |\n\n\n\n## Exercise :pencil2: {auto-animate=\"true\" background-color=\"white\" background-image=\"figures/letters.jpg\" background-opacity=\"0.2\"}\n\n::: {.attribution}\nPhoto courtesy of [@amadorloureiro](https://unsplash.com/@amadorloureiro)\n:::\n\n1.  `letters` is a predefined vector of the English alphabet in R. Use it to extract the 15th letter of the alphabet.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    letters[15]\n    ```\n    :::\n\n\n\n2.  Create a vector `x` with every second letter of the alphabet.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    x <- letters[seq(1, 26, by = 2)]\n    ```\n    :::\n\n\n    \n3.  Use the `!` (not) and the `%in%` (set) operators to remove the vowels from `x` and assign the resulting vector to `y`.\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    y <- x[!x %in% c(\"a\", \"e\", \"i\", \"o\", \"u\")]\n    ```\n    :::\n\n\n\n4.  Replace the lower-case letter \"m\" in `y` by the uper-case letter \"M\".\n\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    y[y == \"m\"] <- \"M\"\n    ```\n    :::\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Missings {background-color=\"white\" background-image=\"figures/missings.jpg\" background-opacity=\"0.5\"}\n\n::: footer\nPhoto courtesy of [@sigmund](https://unsplash.com/de/@sigmund)\n:::\n\n\n\n### What are missings?\n\nMissings are values that are not available for some reason.\n\n::: callout-important\n## Missing values are represented by `NA` (= Not Available).\n:::\n\nMissings can be treated like regular values.\n\n::: columns\n::: {.column width=\"50%\"}\n-   Assign missings to vector\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(1, 2, NA, 4, 5)\n    a\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]  1  2 NA  4  5\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n::: {.column width=\"50%\"}\n-   Replace missings manually\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(1, 2, NA, 4, 5)\n    a[3] <- 9\n    a\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2 9 4 5\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n:::\n\nLogical indexing can be used to identify and replace missings.\n\n::: columns\n::: {.column width=\"50%\"}\n-   Find missings with `is.na()`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(1, 2, NA, 4, 5)\n    is.na(a)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] FALSE FALSE  TRUE FALSE FALSE\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n::: {.column width=\"50%\"}\n-   Replace missings logically\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(1, 2, NA, 4, 5)\n    a[is.na(a)] <- 9\n    a\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2 9 4 5\n    ```\n    \n    \n    :::\n    :::\n\n\n:::\n:::\n\n\n\n### Missings in functions\n\nMany descriptive statistics functions return `NA` if the vector contains missings.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a vector with missings\na <- c(5, 2, NA, 9, 2, NA, NA, 3)\n\nmean(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nrange(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA\n```\n\n\n:::\n:::\n\n\n\nTo avoid this, you can often set the argument `na.rm` to `TRUE` to remove missings before computing the statistic.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(a, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.2\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(a, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n\n```{.r .cell-code}\nrange(a, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 9\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}