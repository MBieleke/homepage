{
  "hash": "e65d5d93160eb8e04a0da1ea275b57f9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"StartR Workshop\"\nsubtitle: \"Methodenfortbildung der ASP\"\ndescription: \"Merging | Reshaping | Aggregating | Pipes | Conditioning & Looping\"\nauthor: \"**Maik Bieleke, PhD**\"\ninstitute: \"University of Konstanz\"\ndate: 11/16/2024\ndate-format: long\nformat: \n  revealjs:\n    transition: slide\n    fontsize: 20pt\n    chalkboard: true\n    slide-number: true\n    theme: [simple, _styles/unikn.scss]\n    footer: \"[https://maikbieleke.com/workshops/startr-2024-asp/](https://maikbieleke.com/workshops/startr-2024-asp/)\"\n    margin: 0.25\n    highlight-style: a11y\nfrom: markdown+emoji\nrevealjs-plugins:\n  - attribution\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n# Merging {background-image=\"figures/06-management/merge.jpg\" background-opacity=\"0.1\"}\n\n::: footer\nPhoto courtesy of [@lg17](https://unsplash.com/de/@lg17)\n:::\n\n## What is merging?\n\nMerging is the process of **combining two (or more) data sets into one**. This is useful when the data is spread across data files that need to be combined for analysis or visualization.\n\n- data from different sources (e.g., survey data and task performance)\n- data from different time points (e.g., pre- and post-test)\n\nMerging requires that the data sets have one variable in common to match the observations.\n\n. . .\n\n:::: {.columns}\n::: {.column width=\"70%\"}\nThere are four types of merging:\n\n- **full join**: keep all observations from both data sets\n- **left join**: keep all observations from the left data set\n- **right join**: keep all observations from the right data set\n- **Inner join**: only keep observations that appear in both data sets\n\nWe use functions from the `dplyr` package.\n:::\n\n::: {.column width=\"30%\"}\n![](figures/06-management/dplyr-hex.png)\n:::\n::::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(dplyr) # if not installed\nlibrary(dplyr)\n```\n:::\n\n\n## Types of merging\n\n![](figures/06-management/merging.jpg){fig-align=\"center\"}\n\n\n## Examples\n\nWe create two data frames with the shared key variable `id`. They have observations from different participants and different variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create two data frames\ndfA <- data.frame(id = c(1, 2, 3), w = c(10, 8, 15), x = c(7, 9, 12))\ndfB <- data.frame(id = c(1, 2, 4), y = c(2, 10, 11), z = c(5, 5, 3))\n```\n:::\n\n\nNow we can use functions from the dplyr package to merge the data frames.\n\n:::: {.columns}\n::: {.column width=\"50%\" .fragment}\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::full_join(dfA, dfB)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id  w  x  y  z\n1  1 10  7  2  5\n2  2  8  9 10  5\n3  3 15 12 NA NA\n4  4 NA NA 11  3\n```\n\n\n:::\n\n```{.r .cell-code}\ndplyr::inner_join(dfA, dfB)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id  w x  y z\n1  1 10 7  2 5\n2  2  8 9 10 5\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\" .fragment}\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::left_join(dfA, dfB)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id  w  x  y  z\n1  1 10  7  2  5\n2  2  8  9 10  5\n3  3 15 12 NA NA\n```\n\n\n:::\n\n```{.r .cell-code}\ndplyr::right_join(dfA, dfB)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id  w  x  y z\n1  1 10  7  2 5\n2  2  8  9 10 5\n3  4 NA NA 11 3\n```\n\n\n:::\n:::\n\n:::\n::::\n\n## Common problems\n\n::: {.incremental}\n- different names of the key variable: use `join_by()`\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  dfA <- data.frame(id = c(1, 2, 3), w = c(10, 8, 15), x = c(7, 9, 12))\n  dfB <- data.frame(IDENT = c(1, 2, 4), z = c(5, 5, 3))\n  dplyr::full_join(dfA, dfB, join_by(id == IDENT))\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    id  w  x  z\n  1  1 10  7  5\n  2  2  8  9  5\n  3  3 15 12 NA\n  4  4 NA NA  3\n  ```\n  \n  \n  :::\n  :::\n\n  \n- multiple key variables: use `by()`\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  dfA <- data.frame(id = c(1, 1, 2, 2), wave = c(1, 2, 1, 2),\n                    anx = c(10, 8, 15, 16), dep = c(7, 9, 12, 11))\n  dfB <- data.frame(id = c(1, 1, 3, 3), wave = c(1, 2, 1, 2),\n                    ang = c(2, 4, 11, 11), dis = c(5, 5, 3, 5))\n  \n  dplyr::full_join(dfA, dfB, by = c(\"id\", \"wave\"))\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n    id wave anx dep ang dis\n  1  1    1  10   7   2   5\n  2  1    2   8   9   4   5\n  3  2    1  15  12  NA  NA\n  4  2    2  16  11  NA  NA\n  5  3    1  NA  NA  11   3\n  6  3    2  NA  NA  11   5\n  ```\n  \n  \n  :::\n  :::\n\n:::\n\n\n\n## {{< iconify solar programming-bold >}} Exercise\n\nA researcher tracks the performance and subjective exertion ratings of athletes during two training sessions. Each athlete's performance metrics and self-reported effort were collected separately. Our goal is to merge these two datasets to analyze how perceived exertion aligns with physical performance.\n\n::: {.incremental}\n1. Create the following data frames by copying the code below:\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code  code-line-numbers=\"false\"}\n   performance <- data.frame(id = c(\"A\", \"A\", \"B\", \"B\", \"C\"), session = c(1, 2, 1, 2, 1),\n                             speed = c(12.5, 13.0, 11.8, 12.0, 12.2), distance = c(5, 6, 4, 5, 5))\n   ratings <- data.frame(id = c(\"A\", \"A\", \"B\", \"B\", \"C\", \"C\"), session = c(1, 2, 1, 2, 1, 2),\n                         exertion = c(7, 8, 6, 5, 7, 9))\n   ```\n   :::\n\n\n2. Which two variables uniquely identify each observation in the data frames?\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n   # id and session\n   ```\n   :::\n\n\n3. Merge the two data frames using a `dplyr::full_join`.\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n   dplyr::full_join(performance, ratings, by = c(\"id\", \"session\"))\n   \n   # dplyr automatically infers the key variables when they have the same name:\n   # dplyr::full_join(performance, ratings)\n   ```\n   :::\n\n\n4. Use `dplyr::left_join()` to keep all athletes from `performance` and add exertion ratings where available. What is the difference to the previous join?\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n   dplyr::left_join(performance, ratings, by = c(\"id\", \"session\"))\n   # Difference: exertion data from Participant C in Session 2 is removed because no performance data is available\n   ```\n   :::\n\n:::\n\n\n\n\n# Reshaping {background-image=\"figures/06-management/stapel.jpg\" background-opacity=\"0.1\"}\n\n::: footer\nPhoto courtesy of [@hansreniers](https://unsplash.com/de/@hansreniers)\n:::\n\n## What is reshaping?\n\nReshaping is the process of **changing the data format without adding or removing information**. This is useful when the data is not in the right format for the desired analysis or visualization.\n\n- repeated measures stored in columns versus rows\n- information stored in variable names versus values\n\n. . .\n\n:::: {.columns}\n::: {.column width=\"70%\"}\nThere are two types of reshaping:\n\n- **wide to long**: transform data from a wide format to a long format\n- **long to wide**: transform data from a long format to a wide format\n\nWe use the `pivot_longer()` and the `pivot_wider()` functions from the `tidyr` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(tidyr) # if not installed\nlibrary(tidyr)\n```\n:::\n\n:::\n\n::: {.column width=\"30%\"}\n![](figures/06-management/tidyr-hex.png)\n:::\n::::\n\n\n\n## Tidy Data\n\n![](figures/06-management/tidy-data.png){fig-align=\"center\"}\n\n::: footer\n<https://doi.org/10.18637/jss.v059.i10>\n:::\n\n## Example\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n**Untidy data:**\n\n![](figures/06-management/untidy-example.png){fig-align=\"center\"}\n:::\n::: {.column width=\"50%\" .fragment}\n**Tidy data:**\n\n![](figures/06-management/tidy-example.png){fig-align=\"center\"}\n:::\n::::\n\n::: footer\n<https://doi.org/10.18637/jss.v059.i10>\n:::\n\n\n\n\n\n## Wide-to-long\n\n:::: {.columns}\n::: {.column width=\"40%\"}\n\n**Wide Format:**\n\nWe start with a data frame in a wide format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a wide data frame\ndfr <- data.frame(\n  id = c(1, 2), \n  a_1 = c(10, 8), \n  a_2 = c(7, 9),\n  b_1 = c(2, 11),\n  b_2 = c(5, 5))\ndfr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id a_1 a_2 b_1 b_2\n1  1  10   7   2   5\n2  2   8   9  11   5\n```\n\n\n:::\n:::\n\n:::\n::: {.column width=\"60%\" .fragment}\n\n**Long Format:**\n\nTransform data frame to long format with `pivot_longer()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# from wide to long\ndfr_long <- pivot_longer(\n  dfr, \n  cols = c(a_1, a_2, b_1, b_2),\n  names_to = \"variable\", \n  values_to = \"value\")\ndfr_long\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 Ã— 3\n     id variable value\n  <dbl> <chr>    <dbl>\n1     1 a_1         10\n2     1 a_2          7\n3     1 b_1          2\n4     1 b_2          5\n5     2 a_1          8\n6     2 a_2          9\n7     2 b_1         11\n8     2 b_2          5\n```\n\n\n:::\n:::\n\n:::\n::::\n\n\n## Long-to-wide\n\n:::: {.columns}\n::: {.column width=\"60%\"}\n\n**Long Format:**\n\nThis time, we start with a data frame in a wide format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a long data frame\ndfr <- data.frame(\n  id = c(1, 1, 1, 1, 2, 2, 2, 2),\n  variable = c(\"a_1\", \"a_2\", \"b_1\", \"b_2\",\n               \"a_1\", \"a_2\", \"b_1\", \"b_2\"),\n  value = c(10, 7, 2, 5, 8, 9, 11, 5))\ndfr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id variable value\n1  1      a_1    10\n2  1      a_2     7\n3  1      b_1     2\n4  1      b_2     5\n5  2      a_1     8\n6  2      a_2     9\n7  2      b_1    11\n8  2      b_2     5\n```\n\n\n:::\n:::\n\n:::\n::: {.column width=\"40%\" .fragment}\n\n**Wide Format:**\n\nTransform data frame to wide with `pivot_wider()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfr_wide <- pivot_wider(\n  dfr,\n  names_from = \"variable\", \n  values_from = \"value\")\ndfr_wide\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã— 5\n     id   a_1   a_2   b_1   b_2\n  <dbl> <dbl> <dbl> <dbl> <dbl>\n1     1    10     7     2     5\n2     2     8     9    11     5\n```\n\n\n:::\n:::\n\n:::\n::::\n\n\n\n## Hidden identifiers\n\nOften variable names in the wide format contain more than one piece of information. For example, the variable `a_1` contains information about the variable `a` and the time point `1`.  This is called a **hidden identifier**. \n\n:::: {.columns}\n::: {.column width=\"40%\"}\n\n**Wide Format:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a wide data frame\ndfr <- data.frame(\n  id = c(1, 2), \n  a_1 = c(10, 8), \n  a_2 = c(7, 9),\n  b_1 = c(2, 11),\n  b_2 = c(5, 5))\ndfr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id a_1 a_2 b_1 b_2\n1  1  10   7   2   5\n2  2   8   9  11   5\n```\n\n\n:::\n:::\n\n:::\n::: {.column width=\"60%\" .fragment}\n\n**Long Format:**\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|6\"}\n# from wide to long\ndfr_long <- pivot_longer(\n  dfr, \n  cols = c(a_1, a_2, b_1, b_2),\n  names_to = c(\"variable\", \"time\"), \n  names_sep = \"_\",\n  values_to = \"value\")\ndfr_long\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 Ã— 4\n     id variable time  value\n  <dbl> <chr>    <chr> <dbl>\n1     1 a        1        10\n2     1 a        2         7\n3     1 b        1         2\n4     1 b        2         5\n5     2 a        1         8\n6     2 a        2         9\n7     2 b        1        11\n8     2 b        2         5\n```\n\n\n:::\n:::\n\n:::\n::::\n\n## {{< iconify solar programming-bold >}} Exercise\n\nA study records athletesâ€™ heart rates and perceived exertion over two sessions. The data is initially in a wide format, with each sessionâ€™s data in separate columns. To analyze trends over time, we need to reshape it into a long format.\n\n::: {.incremental}\n1. Create the following wide-format data frame by copying the code below:\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code  code-line-numbers=\"false\"}\n   data <- data.frame(id = c(101, 102), hr_1 = c(140, 130), hr_2 = c(135, 128),\n                      exertion_1 = c(7, 6), exertion_2 = c(6, 5))\n   ```\n   :::\n\n\n2. Use `tidyr::pivot_longer()` to transform this data into a long format `data_long`, with `id`, `measure`, `session`, and `value` columns. Use the `names_sep = \"_\"` option to split the variable names into measure and session.\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n   data_long <- tidyr::pivot_longer(data, cols = c(hr_1, hr_2, exertion_1, exertion_2),\n                                    names_to = c(\"measure\", \"session\"), names_sep = \"_\")\n   ```\n   :::\n\n\n3. Convert the long-format data back to wide format using `pivot_wider()`, with each sessionâ€™s data in a separate column for each metric.\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n   data_wide <- tidyr::pivot_wider(data_long, names_from = c(\"measure\", \"session\"), values_from = \"value\")\n   ```\n   :::\n\n:::\n\n\n# Aggregating {background-image=\"figures/06-management/funnel.jpg\" background-opacity=\"0.1\"}\n\n::: footer\nPhoto from [shutterstock](https://www.shutterstock.com/image-photo/143149924)\n:::\n \n## What is aggregation?\n\nAggregating is the process of **summarising information from multiple observations into a single piece of information**.\n\n- averaging scale items into an overall score\n- counting the number of observations in a category\n\n. . .\n\n:::: {.columns}\n::: {.column width=\"70%\"}\nThere are two types of aggregation:\n\n- **column-wise**: combine observations from individual columns\n- **row-wise**: combine observations from multiple columns\n\nWe use the `summarize()` function and some helper functions from the `dplyr` package.\n:::\n\n::: {.column width=\"30%\"}\n![](figures/06-management/dplyr-hex.png)\n:::\n::::\n\n\n\n## Column-wise aggregation\n\nColumn-wise aggregation is used to compute summary statistics (e.g., mean, standard deviation) for one ore more columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a wide data frame\ndfr <- data.frame(id = c(1, 2, 3), a_1 = c(10, 8, 5), a_2 = c(7, 9, 2),\n                  b_1 = c(2, 11, 8),  b_2 = c(5, 5, 3)); dfr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id a_1 a_2 b_1 b_2\n1  1  10   7   2   5\n2  2   8   9  11   5\n3  3   5   2   8   3\n```\n\n\n:::\n:::\n\n\n. . .\n\n::: {.fragment .fade-in-then-semi-out}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Compute mean of a single variable\nsummarize(dfr, mean_a1 = mean(a_1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   mean_a1\n1 7.666667\n```\n\n\n:::\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Compute mean and standard deviation of a single variable\nsummarize(dfr, mean_a1 = mean(a_1), sd_a1 = sd(a_1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   mean_a1    sd_a1\n1 7.666667 2.516611\n```\n\n\n:::\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Compute a single mean of multiple variables\nsummarize(dfr, mean_a = mean(c(a_1, a_2)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    mean_a\n1 6.833333\n```\n\n\n:::\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\nThe `across()` function allows us to apply the same function to multiple columns.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Compute separate means of multiple variables with across()\nsummarize(dfr, across(c(a_1, a_2), mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       a_1 a_2\n1 7.666667   6\n```\n\n\n:::\n:::\n\n:::\n\n\n\n\n## Row-wise aggregation\n\nRow-wise aggregation is used to compute summary statistics for multiple columns for each observation. We need to use the `rowwise()` function to apply the aggregation to each row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a wide data frame\ndfr <- data.frame(id = c(1, 2, 3), a_1 = c(10, 8, 5), a_2 = c(7, 9, 2),\n                  b_1 = c(2, 11, 8),  b_2 = c(5, 5, 3)); dfr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id a_1 a_2 b_1 b_2\n1  1  10   7   2   5\n2  2   8   9  11   5\n3  3   5   2   8   3\n```\n\n\n:::\n:::\n\n\n. . .\n\n::: {.fragment .fade-in-then-semi-out}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Compute mean of multiple variables\nsummarize(rowwise(dfr), MEAN = mean(c(a_1, a_2)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 1\n   MEAN\n  <dbl>\n1   8.5\n2   8.5\n3   3.5\n```\n\n\n:::\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Compute mean and standard deviation of multiple variables\nsummarize(rowwise(dfr), MEAN = mean(c(a_1, a_2)), SD = sd(c(a_1, a_2)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 2\n   MEAN    SD\n  <dbl> <dbl>\n1   8.5 2.12 \n2   8.5 0.707\n3   3.5 2.12 \n```\n\n\n:::\n:::\n\n:::\n\n\n\n## Group-wise aggregation\n\nWe can aggregate for different groups separately using `group_by()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a wide data frame\ndfr <- data.frame(id = c(1, 2, 3, 4), condition = c(\"A\", \"A\", \"B\", \"B\"),\n                  a_1 = c(10, 8, 5, 7), a_2 = c(7, 9, 2, 5),\n                  b_1 = c(2, 11, 8, 4),  b_2 = c(5, 5, 3, 1))\ndfr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id condition a_1 a_2 b_1 b_2\n1  1         A  10   7   2   5\n2  2         A   8   9  11   5\n3  3         B   5   2   8   3\n4  4         B   7   5   4   1\n```\n\n\n:::\n:::\n\n\nAggregate for conditions A and B:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compute mean of a single variable for each condition\nsummarize(group_by(dfr, condition), MEAN = mean(a_1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã— 2\n  condition  MEAN\n  <chr>     <dbl>\n1 A             9\n2 B             6\n```\n\n\n:::\n:::\n\n\n## {{< iconify solar programming-bold >}} Exercise\n\nIn this exercise, you have data on athletes' perceived exertion scores during two session in two different conditions (e.g., training and competition).\n\n::: {.incremental}\n1. Create the following data frame by copying the code below:\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code  code-line-numbers=\"false\"}\n   data <- data.frame(id = c(101, 102, 103, 104), condition = c(\"Training\", \"Training\", \"Competition\", \"Competition\"),\n                      rpe_1 = c(7, 6, 8, 6), rpe_2 = c(6, 5, 7, 6))\n   ```\n   :::\n\n\n2. Determine the average RPE score in each session.\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n   # Here, we use `across()` to compute the mean for both rpe_1 and rpe_2.\n   summarize(data, across(c(rpe_1, rpe_2), mean))\n   ```\n   :::\n\n  \n3. Compute the average RPE score for each athlete across sessions.\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n   # This computes the mean of the two columns (rpe_1 and rpe_2) for each athlete.\n   summarize(rowwise(data), mean_rpe = mean(c(rpe_1, rpe_2)))\n   ```\n   :::\n\n   \n4. Compute the average RPE score for each condition across sessions.\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n   # This groups the data by the condition variable and computes the mean for each group.\n   summarize(group_by(data, condition), mean_rpe = mean(c(rpe_1, rpe_2)))\n   ```\n   :::\n\n:::\n\n## Excurse: Pipes\n\nPipes are used to **chain multiple operations together** by inserting the left-hand side as the first argument of the right-hand side. The `dplyr` package provides the `%>%` operator, while base R uses the `|>` operator (activate in Global Options > Code > Editing). The shortcut `Ctrl` + `Shift` + `M` inserts the pipe operator in RStudio.\n\n:::: {.columns}\n::: {.column width=\"70%\"}\n\n**Example:**\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Without pipes\nsummarize(group_by(dfr, condition), MEAN = mean(a_1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã— 2\n  condition  MEAN\n  <chr>     <dbl>\n1 A             9\n2 B             6\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# With pipes\ndfr %>% \n  group_by(condition) %>% \n  summarize(MEAN = mean(a_1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã— 2\n  condition  MEAN\n  <chr>     <dbl>\n1 A             9\n2 B             6\n```\n\n\n:::\n:::\n\n\n:::\n::: {.column width=\"30%\"}\n![The `%>%` pipe comes from the *magrittr* package. Where do you think the package got its name from?](figures/06-management/pipe.jpg)\n:::\n::::\n\nPipes make code more readable and easier to understand, especially when chaining multiple operations together.\n\n\n\n# Conditioning and looping {background-image=\"figures/06-management/loop.jpg\" background-opacity=\"0.1\"}\n\n## Conditional\n\nConditional are used to execute commands only if a certain condition is met. They typically consist of **if and else statements**.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif(1 > 0){\n  print(\"1 is larger than 0\")\n} else {\n  print(\"1 is not larger than 0\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1 is larger than 0\"\n```\n\n\n:::\n:::\n\n\nA frequently used special form is the `ifelse()` statement, which can be used to replace the values of a vector depending on a condition.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Vector from 1 to 10 replaced by \"larger\" if larger than 5, otherwise \"smaller\"\nifelse(1:10 > 5, \"larger\", \"smaller\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"smaller\" \"smaller\" \"smaller\" \"smaller\" \"smaller\" \"larger\"  \"larger\" \n [8] \"larger\"  \"larger\"  \"larger\" \n```\n\n\n:::\n:::\n\n\n## Loops\n\nA loop is used to repeat a sequence of commands multiple times, each time using a different value of a loop index.\n\nA loop consists of\n\n- a **loop index** (e.g., `i`) that takes on different values\n- a **loop vector** (e.g., `1:3`) with all values that the loop index should take\n- a **loop expression** (e.g., `print(i)`) with the commands to be executed for each value of the loop index\n\nThese elements are combined in a **loop statement**:\n\n`for(index in vector){expression}`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:3){print(i)}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n[1] 2\n[1] 3\n```\n\n\n:::\n:::\n\n\nNote that loops are rarely efficient in R (in contrast to other programming languages). \n\n## Example\n\nLet's use the example from above, where we computed means for different columns of a data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a wide data frame\ndfr <- data.frame(id = c(1, 2, 3), a_1 = c(10, 8, 5), a_2 = c(7, 9, 2),\n                  b_1 = c(2, 11, 8),  b_2 = c(5, 5, 3))\n\nfor(column in c(\"a_1\", \"a_2\", \"b_1\", \"b_2\")){\n  var <- dfr[, column]\n  MEAN <- mean(var)\n  print(MEAN)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.666667\n[1] 6\n[1] 7\n[1] 4.333333\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}