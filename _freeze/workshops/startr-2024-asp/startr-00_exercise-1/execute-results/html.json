{
  "hash": "254dc5f93a3e163b3e0218959506a084",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Übung: 'Grundlagen der statistischen Programmierung mit R'\"\nsubtitle: \"Methodenfortbildung der ASP\"\ndescription: \"Exercises for Day 1 of the workshop\"\nauthor: \"Maik Bieleke, PhD\"\ninstitute: \"University of Konstanz\"\ndate: 11/03/2024\ndate-format: long\nformat: \n  html:\n    toc: true\n---\n\n\n# Building blocks\n\n## R as a calculator\n\n@.  A runner completes runs of 5.2 km, 3.8 km, and 7.6 km in one week. Calculate the total distance run.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    5.2 + 3.8 + 7.6\n    ```\n    :::\n\n    \n@.  Calculate the Body Mass Index (BMI) for a person who weighs 70 kg and is 1.75 meters tall. (BMI formula: $\\text{weight} / \\text{height}^2$)\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    70 / (1.75^2)\n    ```\n    :::\n\n\n@.  A runner completes a lap on a circular track with a diameter of 400 meters. Calculate the lap distance (Hint: circumference of a circle = $\\pi \\times \\text{diameter}$).\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    pi * 400\n    ```\n    :::\n\n    \n@.  A swimmer’s training consists of daily distances of 200m, 500m, 300m, 800m, and 400m. Get information about R's `cumsum()` function and use to determine the cumulative distance over the five days.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    cumsum(c(200, 500, 300, 800, 400))\n    ```\n    :::\n\n    \n## Working with objects\n\n@.  Run the following code, which assigns distances run in kilometers and miles to objects `km1`, `km2`, `km3`, `mi1`, and `mi2`.\n\n    ```\n    km1 <- 5  # Distance in km for the first run\n    km2 <- 8  # Distance in km for the second run\n    km3 <- 10 # Distance in km for the third run\n    mi1 <- 3  # Distance in miles for the first run\n    mi2 <- 6  # Distance in miles for the second run\n    ```\n\n@.  Convert the distances in miles to kilometers. The conversion factor is 1 mile = 1.60934 km. Store the results in  new objects called `km4` (for `mi1`) and `km5` (for `mi2`).\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    km4 <- mi1 * 1.60934\n    km5 <- mi2 * 1.60934\n    ```\n    :::\n\n    \n@.  Locate your workspace in RStudio. It should now 7 display variables (`km1`, `km2`, `km3`, `km4`, `km5`, `mi1`, `mi2`,). Remove the objects `mi1` and `mi2` from your workspace. (Hint: The function for this is not on the slides, you have to look it up.)\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    rm(mi1, mi2)\n    ```\n    :::\n\n    \n@.  Calculate the total distance run in kilometers by summing `km1`, `km2`, `km3`, `km4`, and `km5` and save the result as a new object called `total_distance`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    total_distance <- km1 + km2 + km3 + km4 + km5\n    ```\n    :::\n\n\n@.  Store the average distance run in kilometers in a new object called average_distance.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    average_distance <- total_distance / 5\n    ```\n    :::\n\n\n@.  Make a vector called `distances` with the five distances in kilometers (`km1`, `km2`, `km3`, `km4`, and `km5`). \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    distances <- c(km1, km2, km3, km4, km5)\n    ```\n    :::\n\n\n@.  Find the minimum, maximum, length, and mean of the vector `distances`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    min(distances)\n    max(distances)\n    length(distances)\n    mean(distances)\n    ```\n    :::\n\n\n## Packages, scripts, and debugging\n\n@.  Install and load the package `praise`. Use the function `praise()` to get a compliment.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    install.packages(\"praise\")\n    library(praise)\n    praise()\n    ```\n    :::\n\n\n@.  Using the Help tab in RStudio, find the documentation for the `praise()` function. What does the function do?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    ?praise\n    ```\n    :::\n\n    \n@.  Create a new R script in RStudio and save it. Copy the code from the previous exercises into the script and save it. (Hint: You can use History tab to access previous commands). Use comments to create a header for the script (e.g., title, name, date, etc.) and to explain the code.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    # +++++++++++++++++++++++++++++\n    # Exercise 1: R as a calculator\n    # Author:     Max Mustermann\n    # Date:       01/01/2024\n    # +++++++++++++++++++++++++++++\n    \n    # Problem 1: Addition\n    # ~~~~~~~~~~~~~~~~~~~\n    \n    5.2 + 3.8 + 7.6 # add kilometers\n    \n    # etc.\n    ```\n    :::\n\n\n@.  Alex is working with data from the International Physical Activity Questionnaire (IPAQ) and wants to calculate the total physical activity score for a participant. The IPAQ records the time (in minutes) spent in different activity types over a week: vigorous activity, moderate activity, and walking. Alex’s goal is to calculate the total weekly score using the formula below:\n\n    Total Score = (Vigorous Minutes × 8) + (Moderate Minutes × 4) + (Walking Minutes × 3.3)\n\n    Alex has written some code but ran into problems. Can you help Alex identify and correct five issues?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    % Hours spent in each activity type:\n    vig_min = 120\n    mod_min = 240\n    wal_min  = 420\n    \n    % Calculate the total score:\n    total_score = (vig_min * 8.0) + (mod_min * 4,0) + (wal_min * 3.3\n    \n    % Print the total score:\n    total.score\n    ```\n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    # ISSUE 1: incorrect comment syntax (use # instead of //)\n    # ISSUE 2: incorrent assignment operator (use <- instead of =)\n    # ISSUE 3: incorrect decimal point (use 4.0 instead of 4,0)\n    # ISSUE 4: incorrect object name (use total_score instead of total.score)\n    # ISSUE 5: missing closing parenthesis in the formula (add ) after 3.3)\n    \n    # Hours spent in each activity type\n    vig_min <- 120 \n    mod_min <- 240\n    wal_min  <- 420\n    \n    # Calculate the total score\n    total_score <- (vig_min * 8.0) + (mod_min * 4.0) + (wal_min * 3.3)\n    \n    # Print the total score\n    total_score\n    ```\n    :::\n\n\n# Scalars and vectors\n\n## Sequences and repetition\n\nAn experience sampling study collects data on mood ratings from several participants over the course of a week.\n\n@.  The study has 10 participants. Create a vector called `participants` that contains the participant numbers from 1 to 10.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    participants <- 1:10\n    ```\n    :::\n\n\n@.  Assessments take place from Monday to Friday. Create a vector called `weekdays` that contains the names of the days of the week.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    weekdays <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\n    ```\n    :::\n\n\n@.  The mood samples are taken every three hours between 8:00 and 21:00. Create a vector `times` that contains the hours of the day when the mood ratings were collected.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    times <- seq(8, 21, by = 3)\n    ```\n    :::\n\n    \n@.  Compute the total number of mood ratings assessed (assuming no missings).\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    length(participants) * length(weekdays) * length(times)\n    ```\n    :::\n\n    \n@.  Run the following code:\n\n    ```\n    expand.grid(participant = participants, weekday = weekdays, time = times)\n    ```\n    \n    What does the function `expand.grid()` do with the three vectors? Inspect the output of the function and consult the documentation or browse the web for an explanation. How could the function be useful in the context of the experience sampling study?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    # expand.grid() creates a data frame with all combinations of the input\n    # vectors. The output shows all possible combinations of participants, \n    # weekdays, and times, which can be useful for organizing the data for\n    # the study.\n    ```\n    :::\n\n    \n## Indexing and subsetting\n\nYou are working with data collected from athletes during a training study. The vector `heart_rate` represents heart rate measurements (in beats per minute) recorded at regular intervals during a high-intensity interval training (HIIT) session.\n\nHere is the vector:\n\n```\nheart_rate <- c(80, 85, 110, 135, 150, 165, 180, 175, 160, 140, 120, 100)\n```\n    \n@.  There is an error in the data: The value 175 is incorrect and should be replaced with a missing value. Correct the value in the vector accordingly.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    heart_rate[heart_rate == 175] <- NA\n    ```\n    :::\n\n    \n@.  The first value is a baseline measurement taken before the training session and is irrelevant for further analyses. Remove the first value from the vector.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    heart_rate <- heart_rate[-1]\n    ```\n    :::\n\n    \n@.  Subset the heart rate measurements taken in the middle of the session, i.e., select the 4th to the 8th elements.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    heart_rate[4:8]\n    ```\n    :::\n\n\n@.  Use a logical condition to extract all heart rate values greater than 150 bpm.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    heart_rate[heart_rate > 150]\n    ```\n    :::\n\n\n@.  Use a logical condition to subset heart rate values that are either less than 100 bpm or greater than 170 bpm.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    heart_rate[heart_rate < 100 | heart_rate > 170]\n    ```\n    :::\n\n    \n@.  Divide all heart rate values by 10 to convert them on a ratings of perceived exertion (RPE) scale (6 to 20). Store the results in a new vector called `heart_rate_rpe`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    heart_rate_rpe <- heart_rate / 10\n    ```\n    :::\n\n    \n@.  Compute mean, standard deviation, and range of `heart_rate_rpe`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    mean(heart_rate_rpe, na.rm = T)\n    sd(heart_rate_rpe, na.rm = T)\n    range(heart_rate_rpe, na.rm = T)\n    ```\n    :::\n\n    \n\n# Matrices and data frames\n\n## Matrices\n\n@.  Produce an object with the following correlation matrix of three variables and call it `cor_matrix`.\n\n    ```\n         [,1] [,2] [,3]\n    [1,]  1.0 -0.4  0.6\n    [2,] -0.4  1.0 -0.5\n    [3,]  0.6 -0.5  1.0\n    ```\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    cor_matrix <- matrix(c(1.0, -0.4, 0.6, -0.4, 1.0, -0.5, 0.6, -0.5, 1.0), \n                         nrow = 3, ncol = 3)\n    ```\n    :::\n\n    \n@.  The `upper.tri()` function can be used to extract the upper triangle of a matrix. Use this function to extract the upper triangle of the correlation matrix and call it `correlations`. What kind of object is it?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    # You get a vector\n    correlations <- cor_matrix[upper.tri(cor_matrix)]\n    ```\n    :::\n\n    \n@.  Replace the values in `correlations` by their absolute values.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    correlations <- abs(correlations)\n    ```\n    :::\n\n    \n@.  You should now have a vector with three positive correlations coefficients. We want to Fisher-transform these coefficients to z-scores for further computations. This can be done with the following function:\n\n    $$\n    z = \\frac{1}{2} \\log\\left(\\frac{1 + r}{1 - r}\\right)\n    $$\n    \n    Such functions can be defined in R with the `function()` function. Use the documentation and/or the internet to understand the code and then run it to make the function `fisher_z_transform()` available in your workspace.\n    \n    ```\n    fisher_z_transform <- function(r) {\n  0.5 * log((1 + r) / (1 - r))\n    }\n    ```\n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    fisher_z_transform <- function(r) {\n      0.5 * log((1 + r) / (1 - r))\n    }\n    ```\n    :::\n\n    \n@.  Apply the `fisher_z_transform()` function to the vector `correlations` and store the results in a new vector called `correlations_z`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    correlations_z <- fisher_z_transform(correlations)\n    ```\n    :::\n\n\n@.  Compute the mean of the transformed correlations and store the result in a new object called `correlations_z_mean`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    correlations_z_mean <- mean(correlations_z)\n    ```\n    :::\n\n    \n@.  Back-transform the mean z-score to a correlation coefficient using the inverse function:\n\n    $$\n    r = \\frac{e^{2z} - 1}{e^{2z} + 1}\n    $$\n    \n    Define the inverse function `fisher_z_inverse()` in R using the same logic as introduced above. Apply it to the mean z-score to get the mean correlation coefficient.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    fisher_z_inverse <- function(z) {\n      (exp(2 * z) - 1) / (exp(2 * z) + 1)\n    }\n    \n    fisher_z_inverse(correlations_z_mean)\n    ```\n    :::\n\n\n## Data frames\n\n@.  Create a data frame called `data` using the following information:\n\n    - `athlete_id`: Unique identifier for each athlete (values: 1, 2, 3, 4, 5)\n    - `training_type`: Type of training (values: \"Strength\", \"Endurance\", \"Strength\", \"Endurance\", \"Strength\")\n    - `duration_min`: Duration of each training session in minutes (values: 45, 60, 50, 75, 40)\n    - `perceived_effort`: Subjective effort rating on a scale from 1 (very easy) to 10 (extremely hard) (values: 7, 5, 8, 6, 9)\n    \n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    data <- data.frame(\n      id = c(1, 2, 3, 4, 5),\n      training = c(\"Strength\", \"Endurance\", \"Strength\", \"Endurance\", \"Strength\"),\n      duration_min = c(45, 60, 50, 75, 40),\n      perceived_effort = c(7, 5, 8, 6, 9)\n    )\n    ```\n    :::\n\n\n@.  Select only the `id` and `duration_min` columns.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    data[, c(\"id\", \"duration_min\")]\n    # dplyr::select(data, id, duration_min)\n    ```\n    :::\n\n    \n@.  Select rows where the training type is `\"Strength\"`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    data[data$training == \"Strength\", ]\n    # dplyr::filter(data, training == \"Strength\")\n    ```\n    :::\n\n\n@.  Add a new column called `calories_burned` using the formula: `duration_min * 10`. Assume that, on average, athletes burn 10 calories per minute.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    data$calories_burned <- data$duration_min * 10\n    data\n    # dplyr::mutate(data, calories_burned = duration_min * 10)\n    ```\n    :::\n\n\n@.  Rename `duration_min` to `session_duration` and `perceived_effort` to `effort_rating.`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    names(data)[names(data) == \"duration_min\"] <- \"session_duration\"\n    names(data)[names(data) == \"perceived_effort\"] <- \"effort_rating\"\n    \n    # dplyr::rename(data, \n    #              session_duration = duration_min, \n    #              effort_rating = perceived_effort)\n    ```\n    :::\n\n\n@.  Select athletes who did `\"Endurance\"` training and had an `effort_rating` of 6 or more.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    data[data$training == \"Endurance\" & data$effort_rating >= 6, ]\n    # dplyr::filter(data, training == \"Endurance\" & effort_rating >= 6)\n    ```\n    :::\n\n\n@.  Compute the mean `session_duration` and `effort_rating` for each training type.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    mean(data[data$training == \"Strength\",]$session_duration)\n    mean(data[data$training == \"Strength\",]$effort_rating)\n    mean(data[data$training == \"Endurance\",]$session_duration)\n    mean(data[data$training == \"Endurance\",]$effort_rating)\n    \n    # dplyr::summarize(dplyr::filter(data, training == \"Strength\"), \n    #                  mean_duration = mean(session_duration), \n    #                  mean_effort = mean(effort_rating))\n    # dplyr::summarize(dplyr::filter(data, training == \"Endurance\"), \n    #                  mean_duration = mean(session_duration), \n    #                  mean_effort = mean(effort_rating))\n    ```\n    :::",
    "supporting": [
      "startr-00_exercise-1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}