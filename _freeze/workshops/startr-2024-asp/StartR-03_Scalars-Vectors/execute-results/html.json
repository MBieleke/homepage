{
  "hash": "81768bb1385bd1614b103fb0647e0f01",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Scalars and Vectors\"\nsubtitle: \"Methodenfortbildung der ASP\"\ndescription: \"Scalars | Vectors | Indexing | Assignments | Operations | Missings\"\nauthor: \"**Maik Bieleke, PhD**\"\ninstitute: \"University of Konstanz\"\ndate: 11/02/2024\ndate-format: long\nformat: \n  revealjs:\n    transition: slide\n    fontsize: 20pt\n    chalkboard: true\n    slide-number: true\n    theme: [simple, _styles/unikn.scss]\n    footer: \"[https://maikbieleke.com/workshops/startr-2024-asp/](https://maikbieleke.com/workshops/startr-2024-asp/)\"\n    margin: 0.25\n    highlight-style: a11y\nfrom: markdown+emoji\nrevealjs-plugins:\n  - attribution\n---\n\n\n\n# Scalars {background-image=\"figures/03-vectors/scalars.png\" background-opacity=\"0.1\"}\n\n## What are scalars?\n\nScalars are the simplest object in R. They are single values that can be assigned to a variable.\n\n::: callout-important\n## The assignment operator `<-` is used for creating objects like scalars.\n\n`scalar <- ...`\n:::\n\nThe most common types of scalars are **numerical** and **character**.\n\n::: columns\n::: {.column width=\"50%\" .fragment}\n-   numerical scalars\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    x <- 10\n    x\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 10\n    ```\n    \n    \n    :::\n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    y <- 3 / 100\n    y\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 0.03\n    ```\n    \n    \n    :::\n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    z <- (x + y) / y\n    z\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 334.3333\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\" .fragment}\n-   character scalars\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- \"Hello\"\n    a\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"Hello\"\n    ```\n    \n    \n    :::\n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    b <- \"12345\"\n    b\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"12345\"\n    ```\n    \n    \n    :::\n    :::\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    c <- \"Hello World!\"\n    c\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"Hello World!\"\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n## Types of Scalars\n\nR treats different types of scalars differently. For example, you can add two numerical values, but you cannot add two character values.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Adding two numerical values: works fine\na <- 1\nb <- 2\na + b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Adding two character values: gives an error\na <- \"1\"\nb <- \"2\"\na + b\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in a + b: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\n## Mathematical functions \n\nR has many built-in mathematical functions that can be applied to scalars.\n\n::: {style=\"font-size: 75%;\"}\n\n| Function                 | Description                                       | Example                  |\n|-------------------|-----------------------------------|-------------------|\n| `abs(x)`                 | absolute value of x                               | `abs(-4) = 4`            |\n| `sqrt(x)`                | square root of x                                  | `sqrt(25) = 5`           |\n| `ceiling(x), floor(x)`   | smallest integer not less (greater) than x        | `ceiling(3.475) = 4`     |\n| `trunc(x)`               | integer formed by truncating values in x toward 0 | `trunc(5.99) = 5`        |\n| `round(x, n)`            | round x to n decimal places                       | `round(3.475, 2) = 3.48` |\n| `signif(x, n)`           | round x to n significant digits                   | `signif(3.475, 2) = 3.5` |\n| `cos(x), sin(x), tan(x)` | trigonometric functions                           | `cos(2) = -0.416`        |\n| `log(x, n)`              | Logarithm of x to the base n                      | `log(5, 2) = 2.32`       |\n| `log(x), log10(x)`       | natural and common logarithm                      | `log(10) = 2.3026`       |\n| `exp(x)`                 | exponential function                              | `exp(2.3026) = 10`       |\n| `x %% y`                 | x modulo y (remainder of x divided by y)          | `7 %% 3 = 1`             |\n:::\n\nNote that these functions can also be applied to vectors, in which case they will be applied elementwise.\n\n\n\n\n\n\n\n\n\n\n# Vectors {background-image=\"figures/03-vectors/vectors.png\" background-opacity=\"0.1\"}\n\n## What are vectors?\n\nVectors can be thought of as a collection of scalars. They are the most common data type in R.\n\n::: callout-important\n## The `c()` function is used for creating vectors.\n\n`vector <- c(...)`\n:::\n\n::: columns\n::: {.column width=\"50%\" .fragment}\n-   Vectors from scalars\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Combining scalars\n    a <- c(1, 3, 5)\n    a\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 3 5\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\" .fragment}\n-   Vectors from vectors\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Combining vectors\n    a <- c(\"a\", \"b\", \"c\")\n    b <- c(\"d\", \"e\")\n    c <- c(a, b)\n    c\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"a\" \"b\" \"c\" \"d\" \"e\"\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n## Types of vectors\n\n::: columns\n::: {.column width=\"60%\"}\nAnalogous to scalars, vectors can only contain values of the same type. Different types will be coerced into the same type.\n\nFor numerical and character values, coercion will always result in character values.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\na <- c(1, 2, 3, \"a\", \"b\", \"c\")\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\" \"2\" \"3\" \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"40%\"}\n![](figures/03-vectors/coercion.jpg)\n:::\n:::\n\n## Length of vectors\n\nThe length of a vector is the number of elements it contains.\n\n::: callout-important\n## The `length()` function returns the number of elements in a vector.\n:::\n\n::: columns\n::: {.column width=\"50%\" .fragment}\n-   Numerical scalar\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- 1\n    length(a)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1\n    ```\n    \n    \n    :::\n    :::\n\n    \n-   Character scalar\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- \"This is a sentence.\"\n    length(a)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\" .fragment}\n-   Numerical vector\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(11, 2, 333, 4, 5555)\n    length(a)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 5\n    ```\n    \n    \n    :::\n    :::\n\n    \n-   Character vector\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(\"abc\", \"def\", \"geh\")\n    length(a)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 3\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n\n\n# Regular vectors\n\n## Colon operator (`:`)\n\nR has built-in operators and functions for creating regular sequences as vectors.\n\n::: callout-important\n## The colon operator (a`:`b) creates a numeric vector from a to b in steps of 1.\n\n`a:b`\n:::\n\n::: columns\n::: {.column width=\"50%\" .fragment}\n-   Counting up\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    1:5\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2 3 4 5\n    ```\n    \n    \n    :::\n    :::\n\n\n-   Counting down\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    5:1\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 5 4 3 2 1\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\" .fragment}\n-   Decimal values\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    5.5:10.5\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]  5.5  6.5  7.5  8.5  9.5 10.5\n    ```\n    \n    \n    :::\n    :::\n\n\n-   Excluding boundaries\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    5.5:10\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 5.5 6.5 7.5 8.5 9.5\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n## Sequence function: `seq()`\n\nSometimes more flexibility is needed when creating a sequence of numbers than the colon operator can provide.\n\n::: callout-important\n## The `seq()` function creates a numeric vector from a to b with a desired number of steps or a desired length.\n\n`seq(from = a, to = b, by = step, length.out = length)`\n:::\n\n::: columns\n::: {.column width=\"50%\" .fragment}\n-   Steps\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    seq(from = 1, to = 3, \n        by = 0.5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1.0 1.5 2.0 2.5 3.0\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\" .fragment}\n-   Length\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    seq(from = 1, to = 10, \n        length.out = 4)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]  1  4  7 10\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n## Repetition function: `rep()`\n\nWe can also create vectors in which certain values are repeated.\n\n::: callout-important\n## The `rep()` function creates a numeric or character vector in which a scalar or vector is repeated a desired number of times or to a desired length.\n\n`rep(x, times = n, length.out = n, each = n)`\n:::\n\n::: columns\n::: {.column width=\"25%\" .fragment}\n-   Repeat x\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    rep(x = 3, \n        times = 5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 3 3 3 3 3\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"37%\" .fragment}\n-   Repeat values of x\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    rep(x = c(1, 2), \n        each = 2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 1 2 2\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"37%\" .fragment}\n-   Desired length\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    rep(x = c(\"a\", \"b\"), \n        length.out = 5)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"a\" \"b\" \"a\" \"b\" \"a\"\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n\n\n## {{< iconify solar programming-bold >}} Exercise { background-image=\"figures/03-vectors/sequence.jpg\" background-opacity=\"0.1\"}\n\n::: {.attribution}\nPhoto courtesy of [@polarmermaid](https://unsplash.com/@polarmermaid)\n:::\n\n::: {.incremental}\n1.  Create the scalar `x` with the value `10`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    x <- 10\n    ```\n    :::\n\n\n2.  What is the length of vector `y` defined as `y <- 1:x`?\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    y <- 1:x\n    length(y)\n    ```\n    :::\n\n    \n3.  Create a vector `z` from 11 to 100 in steps of 2.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    z <- seq(11, 100, by = 2)\n    ```\n    :::\n\n\n4.  Create a vector `yz` with all elements of `y` and `z` combined.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    yz <- c(y, z)\n    ```\n    :::\n\n:::\n\n\n\n\n\n\n\n\n\n\n\n# Indexing Vectors {background-image=\"figures/03-vectors/select-vector.jpg\" background-opacity=\"0.1\"}\n\n::: footer\nPhoto courtesy of Pixabay\n:::\n\n## Indexing with positive integers: Include\n\nTo select elements of a vector, specify either a scalar or a vector of positive integers corresponding to the values you want to include.\n\n::: callout-important\n## The `[]`operator is used for indexing vectors.\n:::\n\n::: columns\n::: {.column width=\"50%\" .fragment}\n-   Extract a single value using an integer\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Extract the 3rd value\n    x <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\n    x[3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"c\"\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\" .fragment}\n-   Extract several values using a vector\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Extract the first three values\n    x <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\n    x[1:3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"a\" \"b\" \"c\"\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n## Indexing with negative integers: Exclude\n\nTo remove elements of a vector, specify a scalar or a vector of negative integers corresponding to the values you want to exclude.\n\n::: columns\n::: {.column width=\"50%\" .fragment}\n-   Exclude a single value\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Exclude the 5th value\n    x <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\n    x[-5]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"a\" \"b\" \"c\" \"d\"\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\" .fragment}\n-   Exclude several values\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Exclude every second value\n    x <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\n    x[-seq(from = 1, to = 5, by = 2)]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"b\" \"d\"\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n## Logical vectors\n\nWe already know numerical and character vectors. Logical vectors are the third type of vectors in R. They can only have the values `TRUE` and `FALSE` (or `T` and `F` also works).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Create a logical vector manually\nx <- c(TRUE, FALSE, TRUE, FALSE, TRUE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n. . .\n\nLogical vectors are commonly created by applying **logical operations** to numerical or character vectors. One example is the equality operator `==` which returns `TRUE` if two values are equal and `FALSE` otherwise.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nx <- 5 # set the value of x to 5\nx == 5 # check whether x has the value 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n## Logical operators\n\nAn overview of the most common logical operators:\n\n|        |           |        |              |          |                       |\n|--------|-----------|--------|--------------|----------|-----------------------|\n| `a==b` | equal     | `a>b`  | greater than | `a>=b`   | greater than or equal |\n| `a!=b` | not equal | `a<b`  | less than    | `a<=b`   | smaller than or equal |\n| `a|b`  | or        | `!a`   | not          | `any(a)` | at least one          |\n| `a&b`  | and       | `%in%` | in set       | `all(a)` | everything            |\n\n## Examples\n\n::: {.fragment .fade-in-then-semi-out}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n3 < 5 # is 3 smaller than 5?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n5 <= 2 # is 5 smaller than or equal to 2?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n!(3 == 5) # is 3 not equal to 5?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nc(4, 5) %in% c(1, 2, 3, 4) # are 4 and 5 in the vector ?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE\n```\n\n\n:::\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nc(\"a\", \"b\", \"c\", \"d\") == \"c\" # are the values of the vector equal to \"c\"?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nany(c(\"a\", \"b\", \"c\", \"d\") == \"c\" ) # is at least one value equal to \"c\"?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n(3 > 7) | (5 < 10) # is 3 greater than 7 OR 5 smaller than 10?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n:::\n\n::: {.fragment .fade-in-then-semi-out}\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n(3 > 7) & (5 < 10) # is 3 greater than 7 AND 5 smaller than 10?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n:::\n\n\n## Indexing with logical vectors\n\nYou need to provide a logical vector of the same length as the vector you want to subset. The logical vector indicates which elements to include in the subset.\n\n![](figures/03-vectors/logical-indexing.png)\n\n## Examples\n\n::: columns\n::: {.column width=\"50%\" .fragment}\n-   equality operator\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    x <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\n    x[x == \"c\"]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"c\"\n    ```\n    \n    \n    :::\n    :::\n\n\n-   inequality operator\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- 1:5\n    a[a < 3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2\n    ```\n    \n    \n    :::\n    :::\n\n\n-   negation operator\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- 1:5\n    b <- 3\n    a[!a == b]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2 4 5\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\" .fragment}\n-   and-operator\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- 1:10\n    a[a < 4 & a > 6]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    integer(0)\n    ```\n    \n    \n    :::\n    :::\n\n\n-   or-operator\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- 1:10\n    a[a < 3 | a > 7]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]  1  2  8  9 10\n    ```\n    \n    \n    :::\n    :::\n\n\n-   set-operator\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    x <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\n    y <- c(\"b\", \"g\")\n    y[y %in% x]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"b\"\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n## {{< iconify solar programming-bold >}} Exercise {background-image=\"figures/03-vectors/letters.jpg\" background-opacity=\"0.1\"}\n\n::: {.attribution}\nPhoto courtesy of [@amadorloureiro](https://unsplash.com/@amadorloureiro)\n:::\n\n::: {.incremental}\n1.  `letters` is a predefined, ordered vector of the letters of the English alphabet. Type `letters` in the console and press enter to see the vector. \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    letters\n    ```\n    :::\n\n\n2.  Use indexing with a positive integer to show the 15th letter of the alphabet.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    letters[15]\n    ```\n    :::\n\n\n3.  Create a vector `x` with every second letter of the alphabet: 1, 3, 5, etc.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    x <- letters[seq(1, 26, by = 2)] # Alternative: letters[c(T, F)]\n    ```\n    :::\n\n    \n4.  Advanced: Use the `!` (not) and the `%in%` (set) operators to remove the vowels from `x` and assign the resulting vector to `y`.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    y <- x[!x %in% c(\"a\", \"e\", \"i\", \"o\", \"u\")]\n    ```\n    :::\n\n:::\n\n\n\n# Value assignment\n\n## Changing vector values\n\nCombine the principles of **indexing** and the **assignment operation** to change values.\n\n::: columns\n::: {.column width=\"50%\"}\n-   Change a single value\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Define a new vector\n    x <- c(1, 2, 3, 4, 5)\n    \n    # Change the 3rd value to 8\n    x[3] <- 8\n    x\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2 8 4 5\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\" .fragment}\n-   Change several values\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    # Define a new vector\n    x <- c(1, 2, 3, 4, 5)\n    \n    # Change the last two values to 7 and 9\n    x[c(4, 5)] <- c(7, 9)\n    x\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2 3 7 9\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n. . .\n\nAnd of course, we can use logical indexing to change values as well.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nx <- c(\"a\", \"b\", \"b\", \"c\", \"d\", \"b\", \"e\", \"f\", \"b\", \"b\")\n\n# Change all instances of letter \"b\" to letter \"z\"\nx[x == \"b\"] <- \"z\"\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"a\" \"z\" \"z\" \"c\" \"d\" \"z\" \"e\" \"f\" \"z\" \"z\"\n```\n\n\n:::\n:::\n\n\n# Operations on vectors\n\n## Elementwise operations\n\nOperations on vectors are performed element-by-element.\n\n::: columns\n::: {.column width=\"50%\" .incremental}\n-   Adding a single value\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(1, 2, 3, 4, 5)\n    a + 1\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 2 3 4 5 6\n    ```\n    \n    \n    :::\n    :::\n\n\n-   Adding two vectors\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(1, 2, 3, 4, 5)\n    b <- c(10, 20, 30, 40, 50)\n    a + b\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 11 22 33 44 55\n    ```\n    \n    \n    :::\n    :::\n\n\n-   Computing the square root\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    b <- c(4, 9, 16)\n    sqrt(b)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 2 3 4\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\" .incremental}\n-   Dividing by a single value\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    d <- c(10, 100, 1000)\n    d / 10\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]   1  10 100\n    ```\n    \n    \n    :::\n    :::\n\n\n-   Product of two vectors\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(10, 100, 1000)\n    b <- c(2, 3, 4)\n    a * b\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]   20  300 4000\n    ```\n    \n    \n    :::\n    :::\n\n\n-   Exponentiation of vectors\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(2, 3, 4)\n    b <- c(2, 3, 4)\n    a^b\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]   4  27 256\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n## Recycling principle\n\n::: columns\n::: {.column width=\"70%\"}\nAn operation on two vectors of different lengths will recycle the shorter vector to match the length of the longer vector -- without warning.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\na <- c(1, 2, 3, 4, 5)\nb <- c(0.5, 1.0)\na + b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.5 3.0 3.5 5.0 5.5\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"30%\"}\n![](figures/03-vectors/recycling.png)\n:::\n:::\n\n. . .\n\nThis is also why operations with scalars work on vectors: They are simply recycled to the length of the vector.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\na <- c(2, 3, 4)\na^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  9 16\n```\n\n\n:::\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nb <- c(2, 2, 2)\na^b\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  4  9 16\n```\n\n\n:::\n:::\n\n\n## Statistical functions\n\nR has many built-in statistical functions that can be applied to vectors.\n\n| Function    | Description             | Example for `x <- c(1, 2, 2, 5)` |\n|-------------|-------------------------|----------------------------------|\n| `mean(x)`   | mean                    | `mean(x) = 2.5`                  |\n| `sum(x)`    | sum                     | `sum(x) = 10`                    |\n| `median(x)` | median                  | `median(x) = 2`                  |\n| `sd(x)`     | standard deviation      | `sd(x) = 1.732051`               |\n| `var(x)`    | variance                | `var(x) = 3`                     |\n| `range(x)`  | range                   | `range(x) = 1 5`                 |\n| `min(x)`    | minimum                 | `min(x) = 1`                     |\n| `max(x)`    | maximum                 | `max(x) = 5`                     |\n\n\n\n## Other functions\n\nSome other, non-statisitcal functions for vectors are:\n\n| Function    | Description                | Example for `x <- c(3, 8, 8, 5)` |\n|-------------|----------------------------|----------------------------------|\n| `sort(x)`   | sorts the elements         | `sort(x) = 3 5 8 8`              |\n| `rev(x)`    | reversed order of elements | `rev(x) = 5 8 8 3`               |\n| `length(x)` | number of elements         | `length(x) = 4`                  |\n| `unique(x)` | unique elements            | `unique(x) = 3 8 5`              |\n\n\n\n# Missings {background-image=\"figures/03-vectors/missings.jpg\" background-opacity=\"0.1\"}\n\n::: footer\nPhoto courtesy of [@sigmund](https://unsplash.com/de/@sigmund)\n:::\n\n\n\n## What are missings?\n\nMissings are values that are not available for some reason. They can be treated like regular numbers.\n\n::: callout-important\n## Missing values are represented by `NA` (= not available, unknown). \n\nYou might also encounter `NaN` (= not a number; mathematically illdefined), `NULL` (empty object, unknowable), or `Inf` (= infinity).\n:::\n\n::: columns\n::: {.column width=\"50%\" .fragment}\n-   Assign missings to vector\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(1, 2, NA, 4, 5)\n    a\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1]  1  2 NA  4  5\n    ```\n    \n    \n    :::\n    :::\n\n:::\n::: {.column width=\"50%\" .fragment}\n-   Replace missings manually\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(1, 2, NA, 4, 5)\n    a[3] <- 9\n    a\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2 9 4 5\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n. . .\n\nLogical indexing can be used to identify and replace missings.\n\n::: columns\n::: {.column width=\"50%\"}\n-   Find missings with `is.na()`\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(1, 2, NA, 4, 5)\n    is.na(a)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] FALSE FALSE  TRUE FALSE FALSE\n    ```\n    \n    \n    :::\n    :::\n\n:::\n::: {.column width=\"50%\" .fragment}\n-   Replace missings logically\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-line-numbers=\"false\"}\n    a <- c(1, 2, NA, 4, 5)\n    a[is.na(a)] <- 9\n    a\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 1 2 9 4 5\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n\n\n## Missings in functions\n\nMany descriptive statistics functions return `NA` if the vector contains missings.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define a vector with missings\na <- c(5, 2, NA, 9, 2, NA, NA, 3)\n\nmean(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nrange(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA\n```\n\n\n:::\n:::\n\n\n. . .\n\nTo avoid this, these functions have a `na.rm` option that you can set to `TRUE` to remove missings before computing the statistic (i.e., listwise deletion).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(a, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.2\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(a, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21\n```\n\n\n:::\n\n```{.r .cell-code}\nrange(a, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 9\n```\n\n\n:::\n:::\n\n\n\n\n## {{< iconify solar programming-bold >}} Exercise {background-image=\"figures/03-vectors/running-lanes.jpg\" background-opacity=0.1}\n\n::: {.attribution}\nImage: Daniel Foster (Flickr)\n:::\n\nThe four fastest women's 100m times ever recorded are **10.49** seconds by Florence Griffith-Joyner (wind +0.0), **10.54** seconds by Elaine Thompson-Herah (wind +0.9), **10.57** seconds by Sha'Carri Richardson  (wind +4.1), and **10.60** seconds by Shelly-Ann Fraser-Pryce (wind +1.7).\n\n::: {.incremental}\n1.  Create the vector `times` with the four times as shown in the table.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    times <- c(10.49, 10.54, 10.57, 10.60)\n    ```\n    :::\n\n\n2.  Set performances with tailwind >2.0 to `NA` (missing value).\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    times[times > 2] <- NA\n    ```\n    :::\n\n    \n3.  Compute speeds for each time in m/s and save them in a vector called `speeds`. \n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    speeds <- 100 / times\n    ```\n    :::\n\n\n4.  Compute the average speed with a statistical function.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code  code-fold=\"true\" code-summary=\"Solution\" code-line-numbers=\"false\"}\n    mean(speeds, na.rm = TRUE)\n    ```\n    :::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}